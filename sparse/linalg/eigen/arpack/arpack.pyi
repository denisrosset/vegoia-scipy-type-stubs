"""
This type stub file was generated by pyright.
"""

from . import _arpack
from scipy.sparse.linalg.interface import LinearOperator

"""
Find a few eigenvectors and eig"""
__docformat__ = ...
__all__ = ['eigs', 'eigsh', 'svds', 'ArpackError', 'ArpackNoConvergence']
arpack_int = _arpack.timing.nbx.dtype
_type_conv = ...
_ndigits = ...
DNAUPD_ERRORS = ...
SNAUPD_ERRORS = ...
ZNAUPD_ERRORS = ...
CNAUPD_ERRORS = ...
DSAUPD_ERRORS = ...
SSAUPD_ERRORS = ...
DNEUPD_ERRORS = ...
SNEUPD_ERRORS = ...
ZNEUPD_ERRORS = ...
CNEUPD_ERRORS = ...
DSEUPD_ERRORS = ...
SSEUPD_ERRORS = ...
_SAUPD_ERRORS = ...
_NAUPD_ERRORS = ...
_SEUPD_ERRORS = ...
_NEUPD_ERRORS = ...
_SEUPD_WHICH = ...
_NEUPD_WHICH = ...
class ArpackError(RuntimeError):
    """
    ARPACK error
    """
    def __init__(self, info, infodict=...) -> None:
        ...
    


class ArpackNoConvergence(ArpackError):
    """
    ARPACK iteration did not co"""
    def __init__(self, msg, eigenvalues, eigenvectors) -> None:
        ...
    


def choose_ncv(k): # -> int:
    """
    Choose number of lanczos ve"""
    ...

class _ArpackParams:
    def __init__(self, n, k, tp, mode=..., sigma=..., ncv=..., v0=..., maxiter=..., which=..., tol=...) -> None:
        ...
    


class _SymmetricArpackParams(_ArpackParams):
    def __init__(self, n, k, tp, matvec, mode=..., M_matvec=..., Minv_matvec=..., sigma=..., ncv=..., v0=..., maxiter=..., which=..., tol=...) -> None:
        ...
    
    def iterate(self): # -> None:
        ...
    
    def extract(self, return_eigenvectors): # -> tuple[Any, Any] | Any:
        ...
    


class _UnsymmetricArpackParams(_ArpackParams):
    def __init__(self, n, k, tp, matvec, mode=..., M_matvec=..., Minv_matvec=..., sigma=..., ncv=..., v0=..., maxiter=..., which=..., tol=...) -> None:
        ...
    
    def iterate(self): # -> None:
        ...
    
    def extract(self, return_eigenvectors):
        ...
    


class SpLuInv(LinearOperator):
    """
    SpLuInv:
       helper clas"""
    def __init__(self, M) -> None:
        ...
    


class LuInv(LinearOperator):
    """
    LuInv:
       helper class """
    def __init__(self, M) -> None:
        ...
    


def gmres_loose(A, b, tol):
    """
    gmres with looser terminati"""
    ...

class IterInv(LinearOperator):
    """
    IterInv:
       helper clas"""
    def __init__(self, M, ifunc=..., tol=...) -> None:
        ...
    


class IterOpInv(LinearOperator):
    """
    IterOpInv:
       helper cl"""
    def __init__(self, A, M, sigma, ifunc=..., tol=...) -> None:
        ...
    
    @property
    def dtype(self): # -> dtype[Unknown]:
        ...
    


def get_inv_matvec(M, hermitian=..., tol=...): # -> (x: Unknown) -> (Unknown | ndarray[Any, Unknown]):
    ...

def get_OPinv_matvec(A, M, sigma, hermitian=..., tol=...):
    ...

_ARPACK_LOCK = ...
def eigs(A, k=..., M=..., sigma=..., which=..., v0=..., ncv=..., maxiter=..., tol=..., return_eigenvectors=..., Minv=..., OPinv=..., OPpart=...):
    """
    Find k eigenvalues and eige"""
    ...

def eigsh(A, k=..., M=..., sigma=..., which=..., v0=..., ncv=..., maxiter=..., tol=..., return_eigenvectors=..., Minv=..., OPinv=..., mode=...):
    """
    Find k eigenvalues and eige"""
    ...

def svds(A, k=..., ncv=..., tol=..., which=..., v0=..., maxiter=..., return_singular_vectors=..., solver=...):
    """Compute the largest or smallest """
    ...

