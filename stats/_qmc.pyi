"""
This type stub file was generated by pyright.
"""

import numpy as np
import numpy.typing as npt
from abc import ABC, abstractmethod
from typing import ClassVar, List, Optional, TYPE_CHECKING, overload
from typing_extensions import Literal
from scipy._lib._util import DecimalNumber, GeneratorType, IntNumber, SeedType

"""Quasi-Monte Carlo engines and he"""
if TYPE_CHECKING:
    ...
__all__ = ['scale', 'discrepancy', 'update_discrepancy', 'QMCEngine', 'Sobol', 'Halton', 'LatinHypercube', 'MultinomialQMC', 'MultivariateNormalQMC']
@overload
def check_random_state(seed: Optional[IntNumber] = ...) -> np.random.Generator:
    ...

@overload
def check_random_state(seed: GeneratorType) -> GeneratorType:
    ...

def check_random_state(seed=...): # -> Generator | RandomState:
    """Turn `seed` into a `numpy.random"""
    ...

def scale(sample: npt.ArrayLike, l_bounds: npt.ArrayLike, u_bounds: npt.ArrayLike, *, reverse: bool = ...) -> np.ndarray:
    r"""Sample scaling from unit hypercu"""
    ...

def discrepancy(sample: npt.ArrayLike, *, iterative: bool = ..., method: Literal["CD", "WD", "MD", "L2-star"] = ..., workers: IntNumber = ...) -> float:
    """Discrepancy of a given sample.

"""
    ...

def update_discrepancy(x_new: npt.ArrayLike, sample: npt.ArrayLike, initial_disc: DecimalNumber) -> float:
    """Update the centered discrepancy """
    ...

def primes_from_2_to(n: int) -> np.ndarray:
    """Prime numbers from 2 to *n*.

  """
    ...

def n_primes(n: IntNumber) -> List[int]:
    """List of the n-first prime number"""
    ...

def van_der_corput(n: IntNumber, base: IntNumber = ..., *, start_index: IntNumber = ..., scramble: bool = ..., seed: SeedType = ...) -> np.ndarray:
    """Van der Corput sequence.

    Ps"""
    ...

class QMCEngine(ABC):
    """A generic Quasi-Monte Carlo samp"""
    @abstractmethod
    def __init__(self, d: IntNumber, *, seed: SeedType = ...) -> None:
        ...
    
    @abstractmethod
    def random(self, n: IntNumber = ...) -> np.ndarray:
        """Draw `n` in the half-open interv"""
        ...
    
    def reset(self) -> QMCEngine:
        """Reset the engine to base state.
"""
        ...
    
    def fast_forward(self, n: IntNumber) -> QMCEngine:
        """Fast-forward the sequence by `n`"""
        ...
    


class Halton(QMCEngine):
    """Halton sequence.

    Pseudo-ran"""
    def __init__(self, d: IntNumber, *, scramble: bool = ..., seed: SeedType = ...) -> None:
        ...
    
    def random(self, n: IntNumber = ...) -> np.ndarray:
        """Draw `n` in the half-open interv"""
        ...
    


class LatinHypercube(QMCEngine):
    """Latin hypercube sampling (LHS).
"""
    def __init__(self, d: IntNumber, *, centered: bool = ..., seed: SeedType = ...) -> None:
        ...
    
    def random(self, n: IntNumber = ...) -> np.ndarray:
        """Draw `n` in the half-open interv"""
        ...
    


class Sobol(QMCEngine):
    """Engine for generating (scrambled"""
    MAXDIM: ClassVar[int] = ...
    MAXBIT: ClassVar[int] = ...
    def __init__(self, d: IntNumber, *, scramble: bool = ..., seed: SeedType = ...) -> None:
        ...
    
    def random(self, n: IntNumber = ...) -> np.ndarray:
        """Draw next point(s) in the Sobol'"""
        ...
    
    def random_base2(self, m: IntNumber) -> np.ndarray:
        """Draw point(s) from the Sobol' se"""
        ...
    
    def reset(self) -> Sobol:
        """Reset the engine to base state.
"""
        ...
    
    def fast_forward(self, n: IntNumber) -> Sobol:
        """Fast-forward the sequence by `n`"""
        ...
    


class MultivariateNormalQMC(QMCEngine):
    r"""QMC sampling from a multivariate"""
    def __init__(self, mean: npt.ArrayLike, cov: Optional[npt.ArrayLike] = ..., *, cov_root: Optional[npt.ArrayLike] = ..., inv_transform: bool = ..., engine: Optional[QMCEngine] = ..., seed: SeedType = ...) -> None:
        ...
    
    def random(self, n: IntNumber = ...) -> np.ndarray:
        """Draw `n` QMC samples from the mu"""
        ...
    
    def reset(self) -> MultivariateNormalQMC:
        """Reset the engine to base state.
"""
        ...
    


class MultinomialQMC(QMCEngine):
    r"""QMC sampling from a multinomial """
    def __init__(self, pvals: npt.ArrayLike, *, engine: Optional[QMCEngine] = ..., seed: SeedType = ...) -> None:
        ...
    
    def random(self, n: IntNumber = ...) -> np.ndarray:
        """Draw `n` QMC samples from the mu"""
        ...
    
    def reset(self) -> MultinomialQMC:
        """Reset the engine to base state.
"""
        ...
    


