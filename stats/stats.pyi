"""
This type stub file was generated by pyright.
"""

import numpy as np

"""
A collection of basic statistic"""
__all__ = ['find_repeats', 'gmean', 'hmean', 'mode', 'tmean', 'tvar', 'tmin', 'tmax', 'tstd', 'tsem', 'moment', 'variation', 'skew', 'kurtosis', 'describe', 'skewtest', 'kurtosistest', 'normaltest', 'jarque_bera', 'itemfreq', 'scoreatpercentile', 'percentileofscore', 'cumfreq', 'relfreq', 'obrientransform', 'sem', 'zmap', 'zscore', 'iqr', 'gstd', 'median_absolute_deviation', 'median_abs_deviation', 'sigmaclip', 'trimboth', 'trim1', 'trim_mean', 'f_oneway', 'F_onewayConstantInputWarning', 'F_onewayBadInputSizesWarning', 'PearsonRConstantInputWarning', 'PearsonRNearConstantInputWarning', 'pearsonr', 'fisher_exact', 'SpearmanRConstantInputWarning', 'spearmanr', 'pointbiserialr', 'kendalltau', 'weightedtau', 'multiscale_graphcorr', 'linregress', 'siegelslopes', 'theilslopes', 'ttest_1samp', 'ttest_ind', 'ttest_ind_from_stats', 'ttest_rel', 'kstest', 'ks_1samp', 'ks_2samp', 'chisquare', 'power_divergence', 'tiecorrect', 'ranksums', 'kruskal', 'friedmanchisquare', 'rankdata', 'combine_pvalues', 'wasserstein_distance', 'energy_distance', 'brunnermunzel', 'alexandergovern']
def gmean(a, axis=..., dtype=..., weights=...): # -> Any:
    """Compute the geometric mean along"""
    ...

def hmean(a, axis=..., dtype=...): # -> Any:
    """Calculate the harmonic mean alon"""
    ...

ModeResult = ...
def mode(a, axis=..., nan_policy=...): # -> ModeResult:
    """Return an array of the modal (mo"""
    ...

def tmean(a, limits=..., inclusive=..., axis=...): # -> Any:
    """Compute the trimmed mean.

    T"""
    ...

def tvar(a, limits=..., inclusive=..., axis=..., ddof=...): # -> Any:
    """Compute the trimmed variance.

 """
    ...

def tmin(a, lowerlimit=..., axis=..., inclusive=..., nan_policy=...):
    """Compute the trimmed minimum.

  """
    ...

def tmax(a, upperlimit=..., axis=..., inclusive=..., nan_policy=...):
    """Compute the trimmed maximum.

  """
    ...

def tstd(a, limits=..., inclusive=..., axis=..., ddof=...): # -> Any:
    """Compute the trimmed sample stand"""
    ...

def tsem(a, limits=..., inclusive=..., axis=..., ddof=...): # -> Any:
    """Compute the trimmed standard err"""
    ...

def moment(a, moment=..., axis=..., nan_policy=...):
    r"""Calculate the nth moment about t"""
    ...

def variation(a, axis=..., nan_policy=..., ddof=...): # -> Any:
    """Compute the coefficient of varia"""
    ...

def skew(a, axis=..., bias=..., nan_policy=...):
    r"""Compute the sample skewness of a"""
    ...

def kurtosis(a, axis=..., fisher=..., bias=..., nan_policy=...):
    """Compute the kurtosis (Fisher or """
    ...

DescribeResult = ...
def describe(a, axis=..., ddof=..., bias=..., nan_policy=...): # -> DescribeResult:
    """Compute several descriptive stat"""
    ...

SkewtestResult = ...
def skewtest(a, axis=..., nan_policy=..., alternative=...): # -> SkewtestResult:
    """Test whether the skew is differe"""
    ...

KurtosistestResult = ...
def kurtosistest(a, axis=..., nan_policy=..., alternative=...): # -> KurtosistestResult:
    """Test whether a dataset has norma"""
    ...

NormaltestResult = ...
def normaltest(a, axis=..., nan_policy=...): # -> NormaltestResult:
    """Test whether a sample differs fr"""
    ...

Jarque_beraResult = ...
def jarque_bera(x): # -> Jarque_beraResult:
    """Perform the Jarque-Bera goodness"""
    ...

@np.deprecate(message="`itemfreq` is deprecated and wil" "future version. Use instead `np.")
def itemfreq(a): # -> ndarray[Unknown, Unknown]:
    """
Return a 2-D array of item freq"""
    ...

def scoreatpercentile(a, per, limit=..., interpolation_method=..., axis=...): # -> float | ndarray[Unknown, Unknown] | Any:
    """Calculate the score at a given p"""
    ...

def percentileofscore(a, score, kind=...): # -> float:
    """Compute the percentile rank of a"""
    ...

HistogramResult = ...
CumfreqResult = ...
def cumfreq(a, numbins=..., defaultreallimits=..., weights=...): # -> CumfreqResult:
    """Return a cumulative frequency hi"""
    ...

RelfreqResult = ...
def relfreq(a, numbins=..., defaultreallimits=..., weights=...): # -> RelfreqResult:
    """Return a relative frequency hist"""
    ...

def obrientransform(*args): # -> ndarray[Unknown, Unknown]:
    """Compute the O'Brien transform on"""
    ...

def sem(a, axis=..., ddof=..., nan_policy=...): # -> Any:
    """Compute standard error of the me"""
    ...

def zscore(a, axis=..., ddof=..., nan_policy=...): # -> ndarray[Unknown, Unknown]:
    """
    Compute the z score.

    C"""
    ...

def zmap(scores, compare, axis=..., ddof=..., nan_policy=...): # -> ndarray[Unknown, Unknown]:
    """
    Calculate the relative z-sc"""
    ...

def gstd(a, axis=..., ddof=...):
    """
    Calculate the geometric sta"""
    ...

_scale_conversions = ...
def iqr(x, axis=..., rng=..., scale=..., nan_policy=..., interpolation=..., keepdims=...): # -> float | Any:
    r"""
    Compute the interquartile r"""
    ...

def median_abs_deviation(x, axis=..., center=..., scale=..., nan_policy=...):
    r"""
    Compute the median absolute"""
    ...

_median_absolute_deviation_deprec_msg = ...
@np.deprecate(old_name='median_absolute_deviation', new_name='median_abs_deviation', message=_median_absolute_deviation_deprec_msg)
def median_absolute_deviation(x, axis=..., center=..., scale=..., nan_policy=...):
    r"""
Compute the median absolute dev"""
    ...

SigmaclipResult = ...
def sigmaclip(a, low=..., high=...): # -> SigmaclipResult:
    """Perform iterative sigma-clipping"""
    ...

def trimboth(a, proportiontocut, axis=...): # -> ndarray[Unknown, Unknown] | Any:
    """Slice off a proportion of items """
    ...

def trim1(a, proportiontocut, tail=..., axis=...): # -> Any | list[Unknown]:
    """Slice off a proportion from ONE """
    ...

def trim_mean(a, proportiontocut, axis=...): # -> float | Any:
    """Return mean of array after trimm"""
    ...

F_onewayResult = ...
class F_onewayConstantInputWarning(RuntimeWarning):
    """
    Warning generated by `f_one"""
    def __init__(self, msg=...) -> None:
        ...
    


class F_onewayBadInputSizesWarning(RuntimeWarning):
    """
    Warning generated by `f_one"""
    ...


def f_oneway(*args, axis=...): # -> F_onewayResult:
    """Perform one-way ANOVA.

    The """
    ...

def alexandergovern(*args, nan_policy=...): # -> Any:
    """Performs the Alexander Govern te"""
    ...

AlexanderGovernResult = ...
class AlexanderGovernConstantInputWarning(RuntimeWarning):
    """Warning generated by `alexanderg"""
    def __init__(self, msg=...) -> None:
        ...
    


class PearsonRConstantInputWarning(RuntimeWarning):
    """Warning generated by `pearsonr` """
    def __init__(self, msg=...) -> None:
        ...
    


class PearsonRNearConstantInputWarning(RuntimeWarning):
    """Warning generated by `pearsonr` """
    def __init__(self, msg=...) -> None:
        ...
    


def pearsonr(x, y): # -> tuple[float, float] | tuple[Any, float] | tuple[float, Any]:
    r"""
    Pearson correlation coeffic"""
    ...

def fisher_exact(table, alternative=...):
    """Perform a Fisher exact test on a"""
    ...

class SpearmanRConstantInputWarning(RuntimeWarning):
    """Warning generated by `spearmanr`"""
    def __init__(self, msg=...) -> None:
        ...
    


SpearmanrResult = ...
def spearmanr(a, b=..., axis=..., nan_policy=..., alternative=...):
    """Calculate a Spearman correlation"""
    ...

PointbiserialrResult = ...
def pointbiserialr(x, y): # -> PointbiserialrResult:
    r"""Calculate a point biserial corre"""
    ...

KendalltauResult = ...
def kendalltau(x, y, initial_lexsort=..., nan_policy=..., method=..., variant=...):
    """Calculate Kendall's tau, a corre"""
    ...

WeightedTauResult = ...
def weightedtau(x, y, rank=..., weigher=..., additive=...):
    r"""Compute a weighted version of Ke"""
    ...

class _ParallelP:
    """Helper function to calculate par"""
    def __init__(self, x, y, random_states) -> None:
        ...
    
    def __call__(self, index):
        ...
    


MGCResult = ...
def multiscale_graphcorr(x, y, compute_distance=..., reps=..., workers=..., is_twosamp=..., random_state=...):
    r"""Computes the Multiscale Graph Co"""
    ...

Ttest_1sampResult = ...
def ttest_1samp(a, popmean, axis=..., nan_policy=..., alternative=...): # -> tuple[float, float] | Ttest_1sampResult:
    """Calculate the T-test for the mea"""
    ...

Ttest_indResult = ...
def ttest_ind_from_stats(mean1, std1, nobs1, mean2, std2, nobs2, equal_var=..., alternative=...): # -> Ttest_indResult:
    r"""
    T-test for means of two ind"""
    ...

def ttest_ind(a, b, axis=..., equal_var=..., nan_policy=..., permutations=..., random_state=..., alternative=..., trim=...):
    """
    Calculate the T-test for th"""
    ...

Ttest_relResult = ...
def ttest_rel(a, b, axis=..., nan_policy=..., alternative=...):
    """Calculate the t-test on TWO RELA"""
    ...

_power_div_lambda_names = ...
Power_divergenceResult = ...
def power_divergence(f_obs, f_exp=..., ddof=..., axis=..., lambda_=...): # -> Power_divergenceResult:
    """Cressie-Read power divergence st"""
    ...

def chisquare(f_obs, f_exp=..., ddof=..., axis=...): # -> Power_divergenceResult:
    """Calculate a one-way chi-square t"""
    ...

KstestResult = ...
def ks_1samp(x, cdf, args=..., alternative=..., mode=...): # -> KstestResult:
    """
    Performs the one-sample Kol"""
    ...

Ks_2sampResult = KstestResult
def ks_2samp(data1, data2, alternative=..., mode=...):
    """
    Performs the two-sample Kol"""
    ...

def kstest(rvs, cdf, args=..., N=..., alternative=..., mode=...): # -> KstestResult:
    """
    Performs the (one-sample or"""
    ...

def tiecorrect(rankvals): # -> float:
    """Tie correction factor for Mann-W"""
    ...

RanksumsResult = ...
def ranksums(x, y, alternative=...): # -> RanksumsResult:
    """Compute the Wilcoxon rank-sum st"""
    ...

KruskalResult = ...
def kruskal(*args, nan_policy=...):
    """Compute the Kruskal-Wallis H-tes"""
    ...

FriedmanchisquareResult = ...
def friedmanchisquare(*args): # -> FriedmanchisquareResult:
    """Compute the Friedman test for re"""
    ...

BrunnerMunzelResult = ...
def brunnermunzel(x, y, alternative=..., distribution=..., nan_policy=...):
    """Compute the Brunner-Munzel test """
    ...

def combine_pvalues(pvalues, method=..., weights=...): # -> tuple[Any | Unknown, Any | ndarray[Unknown, Unknown]]:
    """
    Combine p-values from indep"""
    ...

def wasserstein_distance(u_values, v_values, u_weights=..., v_weights=...): # -> Any:
    r"""
    Compute the first Wasserste"""
    ...

def energy_distance(u_values, v_values, u_weights=..., v_weights=...): # -> Any:
    r"""Compute the energy distance betw"""
    ...

RepeatedResults = ...
def find_repeats(arr): # -> RepeatedResults:
    """Find repeats and repeat counts.
"""
    ...

def rankdata(a, method=..., *, axis=...):
    """Assign ranks to data, dealing wi"""
    ...

