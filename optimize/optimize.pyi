"""
This type stub file was generated by pyright.
"""

__all__ = ['fmin', 'fmin_powell', 'fmin_bfgs', 'fmin_ncg', 'fmin_cg', 'fminbound', 'brent', 'golden', 'bracket', 'rosen', 'rosen_der', 'rosen_hess', 'rosen_hess_prod', 'brute', 'approx_fprime', 'line_search', 'check_grad', 'OptimizeResult', 'show_options', 'OptimizeWarning']
__docformat__ = ...
_status_message = ...
class MemoizeJac:
    """ Decorator that caches the retur"""
    def __init__(self, fun) -> None:
        ...
    
    def __call__(self, x, *args): # -> None:
        """ returns the the function value """
        ...
    
    def derivative(self, x, *args): # -> None:
        ...
    


class OptimizeResult(dict):
    """ Represents the optimization res"""
    def __getattr__(self, name):
        ...
    
    __setattr__ = ...
    __delattr__ = ...
    def __repr__(self): # -> str:
        ...
    
    def __dir__(self): # -> list[Unknown]:
        ...
    


class OptimizeWarning(UserWarning):
    ...


def is_array_scalar(x): # -> bool:
    """Test whether `x` is either a sca"""
    ...

_epsilon = ...
def vecnorm(x, ord=...): # -> Any:
    ...

def rosen(x): # -> Any:
    """
    The Rosenbrock function.

 """
    ...

def rosen_der(x): # -> ndarray[Unknown, Unknown]:
    """
    The derivative (i.e. gradie"""
    ...

def rosen_hess(x):
    """
    The Hessian matrix of the R"""
    ...

def rosen_hess_prod(x, p): # -> ndarray[Unknown, Unknown]:
    """
    Product of the Hessian matr"""
    ...

def fmin(func, x0, args=..., xtol=..., ftol=..., maxiter=..., maxfun=..., full_output=..., disp=..., retall=..., callback=..., initial_simplex=...): # -> tuple[Unknown, Unknown, Unknown, Unknown, Unknown, Unknown] | tuple[Unknown, Unknown, Unknown, Unknown, Unknown] | tuple[Unknown, Unknown]:
    """
    Minimize a function using t"""
    ...

def approx_fprime(xk, f, epsilon, *args):
    """Finite-difference approximation """
    ...

def check_grad(func, grad, x0, *args, **kwargs): # -> Any:
    """Check the correctness of a gradi"""
    ...

def approx_fhess_p(x0, p, fprime, epsilon, *args):
    ...

class _LineSearchError(RuntimeError):
    ...


def fmin_bfgs(f, x0, fprime=..., args=..., gtol=..., norm=..., epsilon=..., maxiter=..., full_output=..., disp=..., retall=..., callback=...): # -> tuple[Unknown, Unknown, Unknown, Unknown, Unknown, Unknown, Unknown, Unknown] | tuple[Unknown, Unknown, Unknown, Unknown, Unknown, Unknown, Unknown] | tuple[Unknown, Unknown]:
    """
    Minimize a function using t"""
    ...

def fmin_cg(f, x0, fprime=..., args=..., gtol=..., norm=..., epsilon=..., maxiter=..., full_output=..., disp=..., retall=..., callback=...): # -> tuple[Unknown, Unknown, Unknown, Unknown, Unknown, Unknown] | tuple[Unknown, Unknown, Unknown, Unknown, Unknown] | tuple[Unknown, Unknown]:
    """
    Minimize a function using a"""
    ...

def fmin_ncg(f, x0, fprime, fhess_p=..., fhess=..., args=..., avextol=..., epsilon=..., maxiter=..., full_output=..., disp=..., retall=..., callback=...): # -> tuple[Unknown, Unknown, Unknown, Unknown, Unknown, Unknown, Unknown] | tuple[Unknown, Unknown, Unknown, Unknown, Unknown, Unknown] | tuple[Unknown, Unknown]:
    """
    Unconstrained minimization """
    ...

def fminbound(func, x1, x2, args=..., xtol=..., maxfun=..., full_output=..., disp=...): # -> tuple[Unknown, Unknown, Unknown, Unknown]:
    """Bounded minimization for scalar """
    ...

class Brent:
    def __init__(self, func, args=..., tol=..., maxiter=..., full_output=...) -> None:
        ...
    
    def set_bracket(self, brack=...): # -> None:
        ...
    
    def get_bracket_info(self): # -> tuple[Unknown, Unknown, Unknown, Unknown, Unknown, Unknown, Unknown | Literal[3]]:
        ...
    
    def optimize(self): # -> None:
        ...
    
    def get_result(self, full_output=...): # -> tuple[Unknown | None, Unknown | None, int, int | Unknown] | None:
        ...
    


def brent(func, args=..., brack=..., tol=..., full_output=..., maxiter=...): # -> tuple[Unknown, Unknown, Unknown, Unknown]:
    """
    Given a function of one var"""
    ...

def golden(func, args=..., brack=..., tol=..., full_output=..., maxiter=...): # -> tuple[Unknown, Unknown, Unknown]:
    """
    Return the minimum of a fun"""
    ...

def bracket(func, xa=..., xb=..., args=..., grow_limit=..., maxiter=...):
    """
    Bracket the minimum of the """
    ...

def fmin_powell(func, x0, args=..., xtol=..., ftol=..., maxiter=..., maxfun=..., full_output=..., disp=..., retall=..., callback=..., direc=...): # -> tuple[Unknown, Unknown, Unknown, Unknown, Unknown, Unknown, Unknown] | tuple[Unknown, Unknown, Unknown, Unknown, Unknown, Unknown] | tuple[Unknown, Unknown]:
    """
    Minimize a function using m"""
    ...

def brute(func, ranges, args=..., Ns=..., full_output=..., finish=..., disp=..., workers=...):
    """Minimize a function over a given"""
    ...

class _Brute_Wrapper:
    """
    Object to wrap user cost fu"""
    def __init__(self, f, args) -> None:
        ...
    
    def __call__(self, x):
        ...
    


def show_options(solver=..., method=..., disp=...): # -> str | None:
    """
    Show documentation for addi"""
    ...

def main(): # -> None:
    ...

if __name__ == "__main__":
    ...
