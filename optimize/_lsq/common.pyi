"""
This type stub file was generated by pyright.
"""

import numpy as np

"""Functions used by least-squares """
EPS = np.finfo(float).eps
def intersect_trust_region(x, s, Delta): # -> tuple[Unknown, Unknown]:
    """Find the intersection of a line """
    ...

def solve_lsq_trust_region(n, m, uf, s, V, Delta, initial_alpha=..., rtol=..., max_iter=...):
    """Solve a trust-region problem ari"""
    ...

def solve_trust_region_2d(B, g, Delta): # -> tuple[Unknown, Literal[True]] | tuple[Unknown, Literal[False]]:
    """Solve a general trust-region pro"""
    ...

def update_tr_radius(Delta, actual_reduction, predicted_reduction, step_norm, bound_hit): # -> tuple[Unknown, Unknown | Literal[1, 0]]:
    """Update the radius of a trust reg"""
    ...

def build_quadratic_1d(J, g, s, diag=..., s0=...): # -> tuple[Unknown, Unknown, Unknown] | tuple[Unknown, Unknown]:
    """Parameterize a multivariate quad"""
    ...

def minimize_quadratic_1d(a, b, lb, ub, c=...): # -> tuple[Any, Unknown]:
    """Minimize a 1-D quadratic functio"""
    ...

def evaluate_quadratic(J, g, s, diag=...):
    """Compute values of a quadratic fu"""
    ...

def in_bounds(x, lb, ub): # -> bool_:
    """Check if a point lies within bou"""
    ...

def step_size_to_bound(x, s, lb, ub): # -> tuple[Unknown, Any]:
    """Compute a min_step size required"""
    ...

def find_active_constraints(x, lb, ub, rtol=...): # -> ndarray[Unknown, Unknown]:
    """Determine which constraints are """
    ...

def make_strictly_feasible(x, lb, ub, rstep=...):
    """Shift a point to the interior of"""
    ...

def CL_scaling_vector(x, g, lb, ub): # -> tuple[Unknown, Unknown]:
    """Compute Coleman-Li scaling vecto"""
    ...

def reflective_transformation(y, lb, ub): # -> tuple[Unknown, Unknown]:
    """Compute reflective transformatio"""
    ...

def print_header_nonlinear(): # -> None:
    ...

def print_iteration_nonlinear(iteration, nfev, cost, cost_reduction, step_norm, optimality): # -> None:
    ...

def print_header_linear(): # -> None:
    ...

def print_iteration_linear(iteration, cost, cost_reduction, step_norm, optimality): # -> None:
    ...

def compute_grad(J, f): # -> ndarray[Any, Unknown]:
    """Compute gradient of the least-sq"""
    ...

def compute_jac_scale(J, scale_inv_old=...): # -> tuple[NDArray[floating[Any]] | Any, NDArray[floating[Any]] | Any]:
    """Compute variables scale based on"""
    ...

def left_multiplied_operator(J, d): # -> LinearOperator:
    """Return diag(d) J as LinearOperat"""
    ...

def right_multiplied_operator(J, d): # -> LinearOperator:
    """Return J diag(d) as LinearOperat"""
    ...

def regularized_lsq_operator(J, diag): # -> LinearOperator:
    """Return a matrix arising in regul"""
    ...

def right_multiply(J, d, copy=...): # -> LinearOperator:
    """Compute J diag(d).

    If `copy"""
    ...

def left_multiply(J, d, copy=...): # -> LinearOperator:
    """Compute diag(d) J.

    If `copy"""
    ...

def check_termination(dF, F, dx_norm, x_norm, ratio, ftol, xtol): # -> Literal[4, 2, 3] | None:
    """Check termination condition for """
    ...

def scale_for_robust_loss_function(J, f, rho): # -> tuple[Unknown | LinearOperator, Unknown]:
    """Scale Jacobian and residuals for"""
    ...

