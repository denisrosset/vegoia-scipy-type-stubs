"""
This type stub file was generated by pyright.
"""

from numpy import zeros

"""
ltisys -- a collection of class"""
__all__ = ['lti', 'dlti', 'TransferFunction', 'ZerosPolesGain', 'StateSpace', 'lsim', 'lsim2', 'impulse', 'impulse2', 'step', 'step2', 'bode', 'freqresp', 'place_poles', 'dlsim', 'dstep', 'dimpulse', 'dfreqresp', 'dbode']
class LinearTimeInvariant:
    def __new__(cls, *system, **kwargs): # -> Self@LinearTimeInvariant:
        """Create a new object, don't allow"""
        ...
    
    def __init__(self) -> None:
        """
        Initialize the `lti` ba"""
        ...
    
    @property
    def dt(self): # -> None:
        """Return the sampling time of the """
        ...
    
    @property
    def zeros(self):
        """Zeros of the system."""
        ...
    
    @property
    def poles(self):
        """Poles of the system."""
        ...
    


class lti(LinearTimeInvariant):
    r"""
    Continuous-time linear time"""
    def __new__(cls, *system): # -> Self@LinearTimeInvariant:
        """Create an instance of the approp"""
        ...
    
    def __init__(self, *system) -> None:
        """
        Initialize the `lti` ba"""
        ...
    
    def impulse(self, X0=..., T=..., N=...): # -> tuple[ndarray[Unknown, Unknown], Unknown]:
        """
        Return the impulse resp"""
        ...
    
    def step(self, X0=..., T=..., N=...): # -> tuple[Unknown, Unknown]:
        """
        Return the step respons"""
        ...
    
    def output(self, U, T, X0=...):
        """
        Return the response of """
        ...
    
    def bode(self, w=..., n=...): # -> tuple[ndarray[Unknown, Unknown] | Unknown | None, Any, Unknown]:
        """
        Calculate Bode magnitud"""
        ...
    
    def freqresp(self, w=..., n=...): # -> tuple[ndarray[Unknown, Unknown] | Unknown | None, Unknown | Unbound]:
        """
        Calculate the frequency"""
        ...
    
    def to_discrete(self, dt, method=..., alpha=...):
        """Return a discretized version of """
        ...
    


class dlti(LinearTimeInvariant):
    r"""
    Discrete-time linear time i"""
    def __new__(cls, *system, **kwargs): # -> Self@LinearTimeInvariant:
        """Create an instance of the approp"""
        ...
    
    def __init__(self, *system, **kwargs) -> None:
        """
        Initialize the `lti` ba"""
        ...
    
    @property
    def dt(self):
        """Return the sampling time of the """
        ...
    
    @dt.setter
    def dt(self, dt): # -> None:
        ...
    
    def impulse(self, x0=..., t=..., n=...): # -> tuple[Unbound | ndarray[Unknown, Unknown], tuple[ndarray[Unknown, Unknown]] | tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown]] | tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown], ndarray[Unknown, Unknown]] | None]:
        """
        Return the impulse resp"""
        ...
    
    def step(self, x0=..., t=..., n=...): # -> tuple[Unbound | ndarray[Unknown, Unknown], tuple[ndarray[Unknown, Unknown]] | tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown]] | tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown], ndarray[Unknown, Unknown]] | None]:
        """
        Return the step respons"""
        ...
    
    def output(self, u, t, x0=...): # -> tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown], ndarray[Unknown, Unknown]] | tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown]]:
        """
        Return the response of """
        ...
    
    def bode(self, w=..., n=...): # -> tuple[Unknown, Any, Any]:
        r"""
        Calculate Bode magnitud"""
        ...
    
    def freqresp(self, w=..., n=..., whole=...): # -> tuple[Unknown | NDArray[floating[Any]] | None, Unknown | Unbound]:
        """
        Calculate the frequency"""
        ...
    


class TransferFunction(LinearTimeInvariant):
    r"""Linear Time Invariant system cla"""
    def __new__(cls, *system, **kwargs): # -> Self@LinearTimeInvariant:
        """Handle object conversion if inpu"""
        ...
    
    def __init__(self, *system, **kwargs) -> None:
        """Initialize the state space LTI s"""
        ...
    
    def __repr__(self): # -> str:
        """Return representation of the sys"""
        ...
    
    @property
    def num(self): # -> ndarray[Unknown, Unknown] | None:
        """Numerator of the `TransferFuncti"""
        ...
    
    @num.setter
    def num(self, num): # -> None:
        ...
    
    @property
    def den(self): # -> ndarray[Unknown, Unknown] | None:
        """Denominator of the `TransferFunc"""
        ...
    
    @den.setter
    def den(self, den): # -> None:
        ...
    
    def to_tf(self): # -> Self@TransferFunction:
        """
        Return a copy of the cu"""
        ...
    
    def to_zpk(self): # -> ZerosPolesGain:
        """
        Convert system represen"""
        ...
    
    def to_ss(self): # -> StateSpace:
        """
        Convert system represen"""
        ...
    


class TransferFunctionContinuous(TransferFunction, lti):
    r"""
    Continuous-time Linear Time"""
    def to_discrete(self, dt, method=..., alpha=...): # -> TransferFunction:
        """
        Returns the discretized"""
        ...
    


class TransferFunctionDiscrete(TransferFunction, dlti):
    r"""
    Discrete-time Linear Time I"""
    ...


class ZerosPolesGain(LinearTimeInvariant):
    r"""
    Linear Time Invariant syste"""
    def __new__(cls, *system, **kwargs): # -> Self@LinearTimeInvariant:
        """Handle object conversion if inpu"""
        ...
    
    def __init__(self, *system, **kwargs) -> None:
        """Initialize the zeros, poles, gai"""
        ...
    
    def __repr__(self): # -> str:
        """Return representation of the `Ze"""
        ...
    
    @property
    def zeros(self): # -> ndarray[Unknown, Unknown] | None:
        """Zeros of the `ZerosPolesGain` sy"""
        ...
    
    @zeros.setter
    def zeros(self, zeros): # -> None:
        ...
    
    @property
    def poles(self): # -> ndarray[Unknown, Unknown] | None:
        """Poles of the `ZerosPolesGain` sy"""
        ...
    
    @poles.setter
    def poles(self, poles): # -> None:
        ...
    
    @property
    def gain(self): # -> None:
        """Gain of the `ZerosPolesGain` sys"""
        ...
    
    @gain.setter
    def gain(self, gain): # -> None:
        ...
    
    def to_tf(self): # -> TransferFunction:
        """
        Convert system represen"""
        ...
    
    def to_zpk(self): # -> Self@ZerosPolesGain:
        """
        Return a copy of the cu"""
        ...
    
    def to_ss(self): # -> StateSpace:
        """
        Convert system represen"""
        ...
    


class ZerosPolesGainContinuous(ZerosPolesGain, lti):
    r"""
    Continuous-time Linear Time"""
    def to_discrete(self, dt, method=..., alpha=...): # -> ZerosPolesGain:
        """
        Returns the discretized"""
        ...
    


class ZerosPolesGainDiscrete(ZerosPolesGain, dlti):
    r"""
    Discrete-time Linear Time I"""
    ...


class StateSpace(LinearTimeInvariant):
    r"""
    Linear Time Invariant syste"""
    __array_priority__ = ...
    __array_ufunc__ = ...
    def __new__(cls, *system, **kwargs): # -> Self@LinearTimeInvariant:
        """Create new StateSpace object and"""
        ...
    
    def __init__(self, *system, **kwargs) -> None:
        """Initialize the state space lti/d"""
        ...
    
    def __repr__(self): # -> str:
        """Return representation of the `St"""
        ...
    
    def __mul__(self, other): # -> _NotImplementedType | StateSpace:
        """
        Post-multiply another s"""
        ...
    
    def __rmul__(self, other): # -> _NotImplementedType | StateSpace:
        """Pre-multiply a scalar or matrix """
        ...
    
    def __neg__(self): # -> StateSpace:
        """Negate the system (equivalent to"""
        ...
    
    def __add__(self, other): # -> _NotImplementedType | StateSpace:
        """
        Adds two systems in the"""
        ...
    
    def __sub__(self, other): # -> _NotImplementedType | StateSpace:
        ...
    
    def __radd__(self, other): # -> _NotImplementedType | StateSpace:
        ...
    
    def __rsub__(self, other): # -> _NotImplementedType | StateSpace:
        ...
    
    def __truediv__(self, other): # -> _NotImplementedType | StateSpace:
        """
        Divide by a scalar
    """
        ...
    
    @property
    def A(self): # -> ndarray[Unknown, Unknown] | None:
        """State matrix of the `StateSpace`"""
        ...
    
    @A.setter
    def A(self, A): # -> None:
        ...
    
    @property
    def B(self): # -> ndarray[Unknown, Unknown] | None:
        """Input matrix of the `StateSpace`"""
        ...
    
    @B.setter
    def B(self, B): # -> None:
        ...
    
    @property
    def C(self): # -> ndarray[Unknown, Unknown] | None:
        """Output matrix of the `StateSpace"""
        ...
    
    @C.setter
    def C(self, C): # -> None:
        ...
    
    @property
    def D(self): # -> ndarray[Unknown, Unknown] | None:
        """Feedthrough matrix of the `State"""
        ...
    
    @D.setter
    def D(self, D): # -> None:
        ...
    
    def to_tf(self, **kwargs): # -> TransferFunction:
        """
        Convert system represen"""
        ...
    
    def to_zpk(self, **kwargs): # -> ZerosPolesGain:
        """
        Convert system represen"""
        ...
    
    def to_ss(self): # -> Self@StateSpace:
        """
        Return a copy of the cu"""
        ...
    


class StateSpaceContinuous(StateSpace, lti):
    r"""
    Continuous-time Linear Time"""
    def to_discrete(self, dt, method=..., alpha=...): # -> StateSpace:
        """
        Returns the discretized"""
        ...
    


class StateSpaceDiscrete(StateSpace, dlti):
    r"""
    Discrete-time Linear Time I"""
    ...


def lsim2(system, U=..., T=..., X0=..., **kwargs): # -> tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown], Unknown]:
    """
    Simulate output of a contin"""
    ...

def lsim(system, U, T, X0=..., interp=...):
    """
    Simulate output of a contin"""
    ...

def impulse(system, X0=..., T=..., N=...): # -> tuple[ndarray[Unknown, Unknown], Unknown]:
    """Impulse response of continuous-t"""
    ...

def impulse2(system, X0=..., T=..., N=..., **kwargs): # -> tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown]]:
    """
    Impulse response of a singl"""
    ...

def step(system, X0=..., T=..., N=...): # -> tuple[Unknown, Unknown]:
    """Step response of continuous-time"""
    ...

def step2(system, X0=..., T=..., N=..., **kwargs): # -> tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown]]:
    """Step response of continuous-time"""
    ...

def bode(system, w=..., n=...): # -> tuple[ndarray[Unknown, Unknown] | Unknown | None, Any, Unknown]:
    """
    Calculate Bode magnitude an"""
    ...

def freqresp(system, w=..., n=...): # -> tuple[ndarray[Unknown, Unknown] | Unknown | None, Unknown | Unbound]:
    r"""Calculate the frequency response"""
    ...

class Bunch:
    def __init__(self, **kwds) -> None:
        ...
    


def place_poles(A, B, poles, method=..., rtol=..., maxiter=...):
    """
    Compute K such that eigenva"""
    ...

def dlsim(system, u, t=..., x0=...): # -> tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown], ndarray[Unknown, Unknown]] | tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown]]:
    """
    Simulate output of a discre"""
    ...

def dimpulse(system, x0=..., t=..., n=...): # -> tuple[Unbound | ndarray[Unknown, Unknown], tuple[ndarray[Unknown, Unknown]] | Unknown | None]:
    """
    Impulse response of discret"""
    ...

def dstep(system, x0=..., t=..., n=...): # -> tuple[Unbound | ndarray[Unknown, Unknown], tuple[ndarray[Unknown, Unknown]] | Unknown | None]:
    """
    Step response of discrete-t"""
    ...

def dfreqresp(system, w=..., n=..., whole=...): # -> tuple[Unknown | NDArray[floating[Any]] | None, Unknown | Unbound]:
    r"""
    Calculate the frequency res"""
    ...

def dbode(system, w=..., n=...): # -> tuple[Unknown, Any, Any]:
    r"""
    Calculate Bode magnitude an"""
    ...

