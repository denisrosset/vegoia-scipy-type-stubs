"""
This type stub file was generated by pyright.
"""

"""Filter design."""
__all__ = ['findfreqs', 'freqs', 'freqz', 'tf2zpk', 'zpk2tf', 'normalize', 'lp2lp', 'lp2hp', 'lp2bp', 'lp2bs', 'bilinear', 'iirdesign', 'iirfilter', 'butter', 'cheby1', 'cheby2', 'ellip', 'bessel', 'band_stop_obj', 'buttord', 'cheb1ord', 'cheb2ord', 'ellipord', 'buttap', 'cheb1ap', 'cheb2ap', 'ellipap', 'besselap', 'BadCoefficients', 'freqs_zpk', 'freqz_zpk', 'tf2sos', 'sos2tf', 'zpk2sos', 'sos2zpk', 'group_delay', 'sosfreqz', 'iirnotch', 'iirpeak', 'bilinear_zpk', 'lp2lp_zpk', 'lp2hp_zpk', 'lp2bp_zpk', 'lp2bs_zpk', 'gammatone', 'iircomb']
class BadCoefficients(UserWarning):
    """Warning about badly conditioned """
    ...


abs = ...
def findfreqs(num, den, N, kind=...): # -> ndarray[Unknown, Unknown]:
    """
    Find array of frequencies f"""
    ...

def freqs(b, a, worN=..., plot=...): # -> tuple[ndarray[Unknown, Unknown], Unknown]:
    """
    Compute frequency response """
    ...

def freqs_zpk(z, p, k, worN=...): # -> tuple[ndarray[Unknown, Unknown], Unknown]:
    """
    Compute frequency response """
    ...

def freqz(b, a=..., worN=..., whole=..., plot=..., fs=..., include_nyquist=...):
    """
    Compute the frequency respo"""
    ...

def freqz_zpk(z, p, k, worN=..., whole=..., fs=...): # -> tuple[NDArray[floating[Any]], Unknown]:
    r"""
    Compute the frequency respo"""
    ...

def group_delay(system, w=..., whole=..., fs=...): # -> tuple[NDArray[floating[Any]], ndarray[Unknown, Unknown] | NDArray[floating[Any]]]:
    r"""Compute the group delay of a dig"""
    ...

def sosfreqz(sos, worN=..., whole=..., fs=...): # -> tuple[Unbound | Unknown, float | Unknown]:
    r"""
    Compute the frequency respo"""
    ...

def tf2zpk(b, a): # -> tuple[Unknown, Unknown, Unknown]:
    r"""Return zero, pole, gain (z, p, k"""
    ...

def zpk2tf(z, p, k):
    """
    Return polynomial transfer """
    ...

def tf2sos(b, a, pairing=...):
    """
    Return second-order section"""
    ...

def sos2tf(sos): # -> tuple[ndarray[Unknown, Unknown] | Unknown, ndarray[Unknown, Unknown] | Unknown]:
    """
    Return a single transfer fu"""
    ...

def sos2zpk(sos): # -> tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown], float | Unknown]:
    """
    Return zeros, poles, and ga"""
    ...

def zpk2sos(z, p, k, pairing=...):
    """
    Return second-order section"""
    ...

def normalize(b, a): # -> tuple[Unknown, Unknown]:
    """Normalize numerator/denominator """
    ...

def lp2lp(b, a, wo=...): # -> tuple[Unknown, Unknown]:
    r"""
    Transform a lowpass filter """
    ...

def lp2hp(b, a, wo=...): # -> tuple[Unknown, Unknown]:
    r"""
    Transform a lowpass filter """
    ...

def lp2bp(b, a, wo=..., bw=...): # -> tuple[Unknown, Unknown]:
    r"""
    Transform a lowpass filter """
    ...

def lp2bs(b, a, wo=..., bw=...): # -> tuple[Unknown, Unknown]:
    r"""
    Transform a lowpass filter """
    ...

def bilinear(b, a, fs=...): # -> tuple[Unknown, Unknown]:
    r"""
    Return a digital IIR filter"""
    ...

def iirdesign(wp, ws, gpass, gstop, analog=..., ftype=..., output=..., fs=...):
    """Complete IIR digital and analog """
    ...

def iirfilter(N, Wn, rp=..., rs=..., btype=..., analog=..., ftype=..., output=..., fs=...):
    """
    IIR digital and analog filt"""
    ...

def bilinear_zpk(z, p, k, fs): # -> tuple[Unknown, Unknown, Unknown]:
    r"""
    Return a digital IIR filter"""
    ...

def lp2lp_zpk(z, p, k, wo=...): # -> tuple[NDArray[floating[Any]], NDArray[floating[Any]], Unknown]:
    r"""
    Transform a lowpass filter """
    ...

def lp2hp_zpk(z, p, k, wo=...): # -> tuple[Unknown, NDArray[floating[Any]], Unknown]:
    r"""
    Transform a lowpass filter """
    ...

def lp2bp_zpk(z, p, k, wo=..., bw=...): # -> tuple[Unknown, Unknown, Unknown]:
    r"""
    Transform a lowpass filter """
    ...

def lp2bs_zpk(z, p, k, wo=..., bw=...): # -> tuple[Unknown, Unknown, Unknown]:
    r"""
    Transform a lowpass filter """
    ...

def butter(N, Wn, btype=..., analog=..., output=..., fs=...):
    """
    Butterworth digital and ana"""
    ...

def cheby1(N, rp, Wn, btype=..., analog=..., output=..., fs=...):
    """
    Chebyshev type I digital an"""
    ...

def cheby2(N, rs, Wn, btype=..., analog=..., output=..., fs=...):
    """
    Chebyshev type II digital a"""
    ...

def ellip(N, rp, rs, Wn, btype=..., analog=..., output=..., fs=...):
    """
    Elliptic (Cauer) digital an"""
    ...

def bessel(N, Wn, btype=..., analog=..., output=..., norm=..., fs=...):
    """
    Bessel/Thomson digital and """
    ...

def maxflat(): # -> None:
    ...

def yulewalk(): # -> None:
    ...

def band_stop_obj(wp, ind, passb, stopb, gpass, gstop, type): # -> Any:
    """
    Band Stop Objective Functio"""
    ...

def buttord(wp, ws, gpass, gstop, analog=..., fs=...):
    """Butterworth filter order selecti"""
    ...

def cheb1ord(wp, ws, gpass, gstop, analog=..., fs=...):
    """Chebyshev type I filter order se"""
    ...

def cheb2ord(wp, ws, gpass, gstop, analog=..., fs=...):
    """Chebyshev type II filter order s"""
    ...

_POW10_LOG10 = ...
def ellipord(wp, ws, gpass, gstop, analog=..., fs=...):
    """Elliptic (Cauer) filter order se"""
    ...

def buttap(N): # -> tuple[ndarray[Unknown, Unknown], Any, Literal[1]]:
    """Return (z,p,k) for analog protot"""
    ...

def cheb1ap(N, rp): # -> tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown], Unknown] | tuple[ndarray[Unknown, Unknown], Any, Any]:
    """
    Return (z,p,k) for Nth-orde"""
    ...

def cheb2ap(N, rs): # -> tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown], Literal[1]] | tuple[Any, Any, Any]:
    """
    Return (z,p,k) for Nth-orde"""
    ...

EPSILON = ...
_ELLIPDEG_MMAX = ...
_ARC_JAC_SN_MAXITER = ...
def ellipap(N, rp, rs): # -> tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown], Unknown] | tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown], Any] | tuple[Unknown, Unknown, Any]:
    """Return (z,p,k) of Nth-order elli"""
    ...

def besselap(N, norm=...): # -> tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown], float]:
    """
    Return (z,p,k) for analog p"""
    ...

def iirnotch(w0, Q, fs=...): # -> tuple[Any, ndarray[Unknown, Unknown]]:
    """
    Design second-order IIR not"""
    ...

def iirpeak(w0, Q, fs=...): # -> tuple[Any, ndarray[Unknown, Unknown]]:
    """
    Design second-order IIR pea"""
    ...

def iircomb(w0, Q, ftype=..., fs=...): # -> tuple[ndarray[Unknown, Unknown], ndarray[Unknown, Unknown]]:
    """
    Design IIR notching or peak"""
    ...

def gammatone(freq, ftype, order=..., numtaps=..., fs=...): # -> tuple[Unknown | ndarray[Unknown, Unknown] | Unbound, list[float] | ndarray[Unknown, Unknown] | Unbound]:
    """
    Gammatone filter design.

 """
    ...

filter_dict = ...
band_dict = ...
bessel_norms = ...
